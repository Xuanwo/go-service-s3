// Code generated by go generate via internal/cmd/service; DO NOT EDIT.
package s3

import (
	"context"
	"io"

	"github.com/aos-dev/go-storage/v3/pkg/credential"
	"github.com/aos-dev/go-storage/v3/pkg/endpoint"
	"github.com/aos-dev/go-storage/v3/pkg/httpclient"
	"github.com/aos-dev/go-storage/v3/services"
	. "github.com/aos-dev/go-storage/v3/types"
)

var _ credential.Provider
var _ endpoint.Value
var _ Storager
var _ services.ServiceError
var _ httpclient.Options

// Type is the type for s3
const Type = "s3"

// Service available pairs.
const (
	// DefaultServicePairs set default pairs for service actions
	pairDefaultServicePairs = "s3_default_service_pairs"
	// DefaultStoragePairs set default pairs for storager actions
	pairDefaultStoragePairs = "s3_default_storage_pairs"
	// Disable100Continue set this to `true` to disable the SDK adding the `Expect: 100-Continue` header to PUT requests over 2MB of content
	pairDisable100Continue = "s3_disable_100_continue"
	// ExceptedBucketOwner the account ID of the excepted bucket owner
	pairExceptedBucketOwner = "s3_excepted_bucket_owner"
	// ForcePathStyle see http://docs.aws.amazon.com/AmazonS3/latest/dev/VirtualHosting.html for Amazon S3: Virtual Hosting of Buckets
	pairForcePathStyle = "s3_force_path_style"
	// ServerSideEncryption the server-side encryption algorithm used when storing this object in Amazon
	pairServerSideEncryption = "s3_server_side_encryption"
	// ServerSideEncryptionAwsKmsKeyID specifies the AWS KMS key ID to use for object encryption
	pairServerSideEncryptionAwsKmsKeyID = "s3_server_side_encryption_aws_kms_key_id"
	// ServerSideEncryptionBucketKeyEnabled specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS)
	pairServerSideEncryptionBucketKeyEnabled = "s3_server_side_encryption_bucket_key_enabled"
	// ServerSideEncryptionContext specifies the AWS KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
	pairServerSideEncryptionContext = "s3_server_side_encryption_context"
	// ServerSideEncryptionCustomerAlgorithm specifies the algorithm to use to when encrypting the object. The header value must be `AES256`.
	pairServerSideEncryptionCustomerAlgorithm = "s3_server_side_encryption_customer_algorithm"
	// ServerSideEncryptionCustomerKey specifies the customer-provided encryption key for Amazon S3 to use to encrypt/decrypt the source object. It must be 32-byte AES-256 key.
	pairServerSideEncryptionCustomerKey = "s3_server_side_encryption_customer_key"
	// StorageClass
	pairStorageClass = "s3_storage_class"
	// UseAccelerate set this to `true` to enable S3 Accelerate feature
	pairUseAccelerate = "s3_use_accelerate"
	// UseArnRegion set this to `true` to have the S3 service client to use the region specified in the ARN, when an ARN is provided as an argument to a bucket parameter
	pairUseArnRegion = "s3_use_arn_region"
)

// ObjectMetadata stores service metadata for object.
type ObjectMetadata struct {
	// ServerSideEncryption
	ServerSideEncryption string
	// ServerSideEncryptionAwsKmsKeyID
	ServerSideEncryptionAwsKmsKeyID string
	// ServerSideEncryptionBucketKeyEnabled
	ServerSideEncryptionBucketKeyEnabled bool
	// ServerSideEncryptionContext
	ServerSideEncryptionContext string
	// ServerSideEncryptionCustomerAlgorithm
	ServerSideEncryptionCustomerAlgorithm string
	// ServerSideEncryptionCustomerKeyMd5
	ServerSideEncryptionCustomerKeyMd5 string
	// StorageClass
	StorageClass string
}

// GetObjectMetadata will get ObjectMetadata from Object.
//
// - This function should not be called by service implementer.
// - The returning ObjectMetadata is read only and should not be modified.
func GetObjectMetadata(o *Object) ObjectMetadata {
	om, ok := o.GetServiceMetadata()
	if ok {
		return om.(ObjectMetadata)
	}
	return ObjectMetadata{}
}

// setObjectMetadata will set ObjectMetadata into Object.
//
// - This function should only be called once, please make sure all data has been written before set.
func setObjectMetadata(o *Object, om ObjectMetadata) {
	o.SetServiceMetadata(om)
}

// WithDefaultServicePairs will apply default_service_pairs value to Options.
//
// DefaultServicePairs set default pairs for service actions
func WithDefaultServicePairs(v DefaultServicePairs) Pair {
	return Pair{
		Key:   pairDefaultServicePairs,
		Value: v,
	}
}

// WithDefaultStoragePairs will apply default_storage_pairs value to Options.
//
// DefaultStoragePairs set default pairs for storager actions
func WithDefaultStoragePairs(v DefaultStoragePairs) Pair {
	return Pair{
		Key:   pairDefaultStoragePairs,
		Value: v,
	}
}

// WithDisable100Continue will apply disable_100_continue value to Options.
//
// Disable100Continue set this to `true` to disable the SDK adding the `Expect: 100-Continue` header to PUT requests over 2MB of content
func WithDisable100Continue(v bool) Pair {
	return Pair{
		Key:   pairDisable100Continue,
		Value: v,
	}
}

// WithExceptedBucketOwner will apply excepted_bucket_owner value to Options.
//
// ExceptedBucketOwner the account ID of the excepted bucket owner
func WithExceptedBucketOwner(v string) Pair {
	return Pair{
		Key:   pairExceptedBucketOwner,
		Value: v,
	}
}

// WithForcePathStyle will apply force_path_style value to Options.
//
// ForcePathStyle see http://docs.aws.amazon.com/AmazonS3/latest/dev/VirtualHosting.html for Amazon S3: Virtual Hosting of Buckets
func WithForcePathStyle(v bool) Pair {
	return Pair{
		Key:   pairForcePathStyle,
		Value: v,
	}
}

// WithServerSideEncryption will apply server_side_encryption value to Options.
//
// ServerSideEncryption the server-side encryption algorithm used when storing this object in Amazon
func WithServerSideEncryption(v string) Pair {
	return Pair{
		Key:   pairServerSideEncryption,
		Value: v,
	}
}

// WithServerSideEncryptionAwsKmsKeyID will apply server_side_encryption_aws_kms_key_id value to Options.
//
// ServerSideEncryptionAwsKmsKeyID specifies the AWS KMS key ID to use for object encryption
func WithServerSideEncryptionAwsKmsKeyID(v string) Pair {
	return Pair{
		Key:   pairServerSideEncryptionAwsKmsKeyID,
		Value: v,
	}
}

// WithServerSideEncryptionBucketKeyEnabled will apply server_side_encryption_bucket_key_enabled value to Options.
//
// ServerSideEncryptionBucketKeyEnabled specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using AWS KMS (SSE-KMS)
func WithServerSideEncryptionBucketKeyEnabled(v bool) Pair {
	return Pair{
		Key:   pairServerSideEncryptionBucketKeyEnabled,
		Value: v,
	}
}

// WithServerSideEncryptionContext will apply server_side_encryption_context value to Options.
//
// ServerSideEncryptionContext specifies the AWS KMS Encryption Context to use for object encryption. The value of this header is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
func WithServerSideEncryptionContext(v string) Pair {
	return Pair{
		Key:   pairServerSideEncryptionContext,
		Value: v,
	}
}

// WithServerSideEncryptionCustomerAlgorithm will apply server_side_encryption_customer_algorithm value to Options.
//
// ServerSideEncryptionCustomerAlgorithm specifies the algorithm to use to when encrypting the object. The header value must be `AES256`.
func WithServerSideEncryptionCustomerAlgorithm(v string) Pair {
	return Pair{
		Key:   pairServerSideEncryptionCustomerAlgorithm,
		Value: v,
	}
}

// WithServerSideEncryptionCustomerKey will apply server_side_encryption_customer_key value to Options.
//
// ServerSideEncryptionCustomerKey specifies the customer-provided encryption key for Amazon S3 to use to encrypt/decrypt the source object. It must be 32-byte AES-256 key.
func WithServerSideEncryptionCustomerKey(v []byte) Pair {
	return Pair{
		Key:   pairServerSideEncryptionCustomerKey,
		Value: v,
	}
}

// WithStorageClass will apply storage_class value to Options.
//
// StorageClass
func WithStorageClass(v string) Pair {
	return Pair{
		Key:   pairStorageClass,
		Value: v,
	}
}

// WithUseAccelerate will apply use_accelerate value to Options.
//
// UseAccelerate set this to `true` to enable S3 Accelerate feature
func WithUseAccelerate(v bool) Pair {
	return Pair{
		Key:   pairUseAccelerate,
		Value: v,
	}
}

// WithUseArnRegion will apply use_arn_region value to Options.
//
// UseArnRegion set this to `true` to have the S3 service client to use the region specified in the ARN, when an ARN is provided as an argument to a bucket parameter
func WithUseArnRegion(v bool) Pair {
	return Pair{
		Key:   pairUseArnRegion,
		Value: v,
	}
}

// pairServiceNew is the parsed struct
type pairServiceNew struct {
	pairs []Pair

	// Required pairs
	HasCredential bool
	Credential    string
	// Optional pairs
	HasDefaultServicePairs bool
	DefaultServicePairs    DefaultServicePairs
	HasDisable100Continue  bool
	Disable100Continue     bool
	HasEndpoint            bool
	Endpoint               string
	HasForcePathStyle      bool
	ForcePathStyle         bool
	HasHTTPClientOptions   bool
	HTTPClientOptions      *httpclient.Options
	HasUseAccelerate       bool
	UseAccelerate          bool
	HasUseArnRegion        bool
	UseArnRegion           bool
	// Generated pairs
}

// parsePairServiceNew will parse Pair slice into *pairServiceNew
func parsePairServiceNew(opts []Pair) (pairServiceNew, error) {
	result := pairServiceNew{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		case "credential":
			if result.HasCredential {
				continue
			}
			result.HasCredential = true
			result.Credential = v.Value.(string)
		// Optional pairs
		case pairDefaultServicePairs:
			if result.HasDefaultServicePairs {
				continue
			}
			result.HasDefaultServicePairs = true
			result.DefaultServicePairs = v.Value.(DefaultServicePairs)
		case pairDisable100Continue:
			if result.HasDisable100Continue {
				continue
			}
			result.HasDisable100Continue = true
			result.Disable100Continue = v.Value.(bool)
		case "endpoint":
			if result.HasEndpoint {
				continue
			}
			result.HasEndpoint = true
			result.Endpoint = v.Value.(string)
		case pairForcePathStyle:
			if result.HasForcePathStyle {
				continue
			}
			result.HasForcePathStyle = true
			result.ForcePathStyle = v.Value.(bool)
		case "http_client_options":
			if result.HasHTTPClientOptions {
				continue
			}
			result.HasHTTPClientOptions = true
			result.HTTPClientOptions = v.Value.(*httpclient.Options)
		case pairUseAccelerate:
			if result.HasUseAccelerate {
				continue
			}
			result.HasUseAccelerate = true
			result.UseAccelerate = v.Value.(bool)
		case pairUseArnRegion:
			if result.HasUseArnRegion {
				continue
			}
			result.HasUseArnRegion = true
			result.UseArnRegion = v.Value.(bool)
			// Generated pairs
		}
	}
	if !result.HasCredential {
		return pairServiceNew{}, services.PairRequiredError{Keys: []string{"credential"}}
	}

	return result, nil
}

// DefaultServicePairs is default pairs for specific action
type DefaultServicePairs struct {
	Create []Pair
	Delete []Pair
	Get    []Pair
	List   []Pair
}

// pairServiceCreate is the parsed struct
type pairServiceCreate struct {
	pairs []Pair

	// Required pairs
	HasLocation bool
	Location    string
	// Optional pairs
	// Generated pairs
}

// parsePairServiceCreate will parse Pair slice into *pairServiceCreate
func (s *Service) parsePairServiceCreate(opts []Pair) (pairServiceCreate, error) {
	result := pairServiceCreate{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		case "location":
			result.HasLocation = true
			result.Location = v.Value.(string)
		// Optional pairs
		// Generated pairs
		default:

			continue

		}
	}
	if !result.HasLocation {
		return pairServiceCreate{}, services.PairRequiredError{Keys: []string{"location"}}
	}

	return result, nil
}

// pairServiceDelete is the parsed struct
type pairServiceDelete struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	HasLocation            bool
	Location               string
	// Generated pairs
}

// parsePairServiceDelete will parse Pair slice into *pairServiceDelete
func (s *Service) parsePairServiceDelete(opts []Pair) (pairServiceDelete, error) {
	result := pairServiceDelete{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "location":
			result.HasLocation = true
			result.Location = v.Value.(string)
		// Generated pairs
		default:

			continue

		}
	}

	return result, nil
}

// pairServiceGet is the parsed struct
type pairServiceGet struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasLocation bool
	Location    string
	// Generated pairs
}

// parsePairServiceGet will parse Pair slice into *pairServiceGet
func (s *Service) parsePairServiceGet(opts []Pair) (pairServiceGet, error) {
	result := pairServiceGet{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case "location":
			result.HasLocation = true
			result.Location = v.Value.(string)
		// Generated pairs
		default:

			continue

		}
	}

	return result, nil
}

// pairServiceList is the parsed struct
type pairServiceList struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairServiceList will parse Pair slice into *pairServiceList
func (s *Service) parsePairServiceList(opts []Pair) (pairServiceList, error) {
	result := pairServiceList{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			continue

		}
	}

	return result, nil
}

// Create will create a new storager instance.
//
// This function will create a context by default.
func (s *Service) Create(name string, pairs ...Pair) (store Storager, err error) {
	ctx := context.Background()
	return s.CreateWithContext(ctx, name, pairs...)
}

// CreateWithContext will create a new storager instance.
func (s *Service) CreateWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	pairs = append(pairs, s.defaultPairs.Create...)
	var opt pairServiceCreate

	defer func() {
		err = s.formatError("create", err, name)
	}()

	opt, err = s.parsePairServiceCreate(pairs)
	if err != nil {
		return
	}

	return s.create(ctx, name, opt)
}

// Delete will delete a storager instance.
//
// This function will create a context by default.
func (s *Service) Delete(name string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, name, pairs...)
}

// DeleteWithContext will delete a storager instance.
func (s *Service) DeleteWithContext(ctx context.Context, name string, pairs ...Pair) (err error) {
	pairs = append(pairs, s.defaultPairs.Delete...)
	var opt pairServiceDelete

	defer func() {
		err = s.formatError("delete", err, name)
	}()

	opt, err = s.parsePairServiceDelete(pairs)
	if err != nil {
		return
	}

	return s.delete(ctx, name, opt)
}

// Get will get a valid storager instance for service.
//
// This function will create a context by default.
func (s *Service) Get(name string, pairs ...Pair) (store Storager, err error) {
	ctx := context.Background()
	return s.GetWithContext(ctx, name, pairs...)
}

// GetWithContext will get a valid storager instance for service.
func (s *Service) GetWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	pairs = append(pairs, s.defaultPairs.Get...)
	var opt pairServiceGet

	defer func() {
		err = s.formatError("get", err, name)
	}()

	opt, err = s.parsePairServiceGet(pairs)
	if err != nil {
		return
	}

	return s.get(ctx, name, opt)
}

// List will list all storager instances under this service.
//
// This function will create a context by default.
func (s *Service) List(pairs ...Pair) (sti *StoragerIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, pairs...)
}

// ListWithContext will list all storager instances under this service.
func (s *Service) ListWithContext(ctx context.Context, pairs ...Pair) (sti *StoragerIterator, err error) {
	pairs = append(pairs, s.defaultPairs.List...)
	var opt pairServiceList

	defer func() {

		err = s.formatError("list", err, "")
	}()

	opt, err = s.parsePairServiceList(pairs)
	if err != nil {
		return
	}

	return s.list(ctx, opt)
}

// pairStorageNew is the parsed struct
type pairStorageNew struct {
	pairs []Pair

	// Required pairs
	HasLocation bool
	Location    string
	HasName     bool
	Name        string
	// Optional pairs
	HasDefaultStoragePairs bool
	DefaultStoragePairs    DefaultStoragePairs
	HasPairPolicy          bool
	PairPolicy             PairPolicy
	HasWorkDir             bool
	WorkDir                string
	// Generated pairs
}

// parsePairStorageNew will parse Pair slice into *pairStorageNew
func parsePairStorageNew(opts []Pair) (pairStorageNew, error) {
	result := pairStorageNew{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		case "name":
			if result.HasName {
				continue
			}
			result.HasName = true
			result.Name = v.Value.(string)
		// Optional pairs
		case pairDefaultStoragePairs:
			if result.HasDefaultStoragePairs {
				continue
			}
			result.HasDefaultStoragePairs = true
			result.DefaultStoragePairs = v.Value.(DefaultStoragePairs)
		case "pair_policy":
			if result.HasPairPolicy {
				continue
			}
			result.HasPairPolicy = true
			result.PairPolicy = v.Value.(PairPolicy)
		case "work_dir":
			if result.HasWorkDir {
				continue
			}
			result.HasWorkDir = true
			result.WorkDir = v.Value.(string)
			// Generated pairs
		}
	}
	if !result.HasLocation {
		return pairStorageNew{}, services.PairRequiredError{Keys: []string{"location"}}
	}
	if !result.HasName {
		return pairStorageNew{}, services.PairRequiredError{Keys: []string{"name"}}
	}

	return result, nil
}

// DefaultStoragePairs is default pairs for specific action
type DefaultStoragePairs struct {
	CompleteMultipart []Pair
	Create            []Pair
	CreateMultipart   []Pair
	Delete            []Pair
	List              []Pair
	ListMultipart     []Pair
	Metadata          []Pair
	Read              []Pair
	Stat              []Pair
	Write             []Pair
	WriteMultipart    []Pair
}

// pairStorageCompleteMultipart is the parsed struct
type pairStorageCompleteMultipart struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	// Generated pairs
}

// parsePairStorageCompleteMultipart will parse Pair slice into *pairStorageCompleteMultipart
func (s *Storage) parsePairStorageCompleteMultipart(opts []Pair) (pairStorageCompleteMultipart, error) {
	result := pairStorageCompleteMultipart{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.CompleteMultipart {
				return pairStorageCompleteMultipart{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageCreate is the parsed struct
type pairStorageCreate struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageCreate will parse Pair slice into *pairStorageCreate
func (s *Storage) parsePairStorageCreate(opts []Pair) (pairStorageCreate, error) {
	result := pairStorageCreate{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Create {
				return pairStorageCreate{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageCreateMultipart is the parsed struct
type pairStorageCreateMultipart struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasServerSideEncryption                  bool
	ServerSideEncryption                     string
	HasServerSideEncryptionAwsKmsKeyID       bool
	ServerSideEncryptionAwsKmsKeyID          string
	HasServerSideEncryptionBucketKeyEnabled  bool
	ServerSideEncryptionBucketKeyEnabled     bool
	HasServerSideEncryptionContext           bool
	ServerSideEncryptionContext              string
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	// Generated pairs
}

// parsePairStorageCreateMultipart will parse Pair slice into *pairStorageCreateMultipart
func (s *Storage) parsePairStorageCreateMultipart(opts []Pair) (pairStorageCreateMultipart, error) {
	result := pairStorageCreateMultipart{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case pairServerSideEncryption:
			result.HasServerSideEncryption = true
			result.ServerSideEncryption = v.Value.(string)
		case pairServerSideEncryptionAwsKmsKeyID:
			result.HasServerSideEncryptionAwsKmsKeyID = true
			result.ServerSideEncryptionAwsKmsKeyID = v.Value.(string)
		case pairServerSideEncryptionBucketKeyEnabled:
			result.HasServerSideEncryptionBucketKeyEnabled = true
			result.ServerSideEncryptionBucketKeyEnabled = v.Value.(bool)
		case pairServerSideEncryptionContext:
			result.HasServerSideEncryptionContext = true
			result.ServerSideEncryptionContext = v.Value.(string)
		case pairServerSideEncryptionCustomerAlgorithm:
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case pairServerSideEncryptionCustomerKey:
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.CreateMultipart {
				return pairStorageCreateMultipart{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageDelete is the parsed struct
type pairStorageDelete struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	HasMultipartID         bool
	MultipartID            string
	// Generated pairs
}

// parsePairStorageDelete will parse Pair slice into *pairStorageDelete
func (s *Storage) parsePairStorageDelete(opts []Pair) (pairStorageDelete, error) {
	result := pairStorageDelete{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "multipart_id":
			result.HasMultipartID = true
			result.MultipartID = v.Value.(string)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Delete {
				return pairStorageDelete{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageList is the parsed struct
type pairStorageList struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	HasListMode            bool
	ListMode               ListMode
	// Generated pairs
}

// parsePairStorageList will parse Pair slice into *pairStorageList
func (s *Storage) parsePairStorageList(opts []Pair) (pairStorageList, error) {
	result := pairStorageList{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "list_mode":
			result.HasListMode = true
			result.ListMode = v.Value.(ListMode)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.List {
				return pairStorageList{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageListMultipart is the parsed struct
type pairStorageListMultipart struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	// Generated pairs
}

// parsePairStorageListMultipart will parse Pair slice into *pairStorageListMultipart
func (s *Storage) parsePairStorageListMultipart(opts []Pair) (pairStorageListMultipart, error) {
	result := pairStorageListMultipart{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.ListMultipart {
				return pairStorageListMultipart{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageMetadata is the parsed struct
type pairStorageMetadata struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	// Generated pairs
}

// parsePairStorageMetadata will parse Pair slice into *pairStorageMetadata
func (s *Storage) parsePairStorageMetadata(opts []Pair) (pairStorageMetadata, error) {
	result := pairStorageMetadata{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Metadata {
				return pairStorageMetadata{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageRead is the parsed struct
type pairStorageRead struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasIoCallback                            bool
	IoCallback                               func([]byte)
	HasOffset                                bool
	Offset                                   int64
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	HasSize                                  bool
	Size                                     int64
	// Generated pairs
}

// parsePairStorageRead will parse Pair slice into *pairStorageRead
func (s *Storage) parsePairStorageRead(opts []Pair) (pairStorageRead, error) {
	result := pairStorageRead{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "io_callback":
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
		case "offset":
			result.HasOffset = true
			result.Offset = v.Value.(int64)
		case pairServerSideEncryptionCustomerAlgorithm:
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case pairServerSideEncryptionCustomerKey:
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		case "size":
			result.HasSize = true
			result.Size = v.Value.(int64)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Read {
				return pairStorageRead{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageStat is the parsed struct
type pairStorageStat struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	// Generated pairs
}

// parsePairStorageStat will parse Pair slice into *pairStorageStat
func (s *Storage) parsePairStorageStat(opts []Pair) (pairStorageStat, error) {
	result := pairStorageStat{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case pairServerSideEncryptionCustomerAlgorithm:
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case pairServerSideEncryptionCustomerKey:
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Stat {
				return pairStorageStat{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageWrite is the parsed struct
type pairStorageWrite struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasContentMd5                            bool
	ContentMd5                               string
	HasContentType                           bool
	ContentType                              string
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasIoCallback                            bool
	IoCallback                               func([]byte)
	HasServerSideEncryption                  bool
	ServerSideEncryption                     string
	HasServerSideEncryptionAwsKmsKeyID       bool
	ServerSideEncryptionAwsKmsKeyID          string
	HasServerSideEncryptionBucketKeyEnabled  bool
	ServerSideEncryptionBucketKeyEnabled     bool
	HasServerSideEncryptionContext           bool
	ServerSideEncryptionContext              string
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	HasStorageClass                          bool
	StorageClass                             string
	// Generated pairs
}

// parsePairStorageWrite will parse Pair slice into *pairStorageWrite
func (s *Storage) parsePairStorageWrite(opts []Pair) (pairStorageWrite, error) {
	result := pairStorageWrite{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case "content_md5":
			result.HasContentMd5 = true
			result.ContentMd5 = v.Value.(string)
		case "content_type":
			result.HasContentType = true
			result.ContentType = v.Value.(string)
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "io_callback":
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
		case pairServerSideEncryption:
			result.HasServerSideEncryption = true
			result.ServerSideEncryption = v.Value.(string)
		case pairServerSideEncryptionAwsKmsKeyID:
			result.HasServerSideEncryptionAwsKmsKeyID = true
			result.ServerSideEncryptionAwsKmsKeyID = v.Value.(string)
		case pairServerSideEncryptionBucketKeyEnabled:
			result.HasServerSideEncryptionBucketKeyEnabled = true
			result.ServerSideEncryptionBucketKeyEnabled = v.Value.(bool)
		case pairServerSideEncryptionContext:
			result.HasServerSideEncryptionContext = true
			result.ServerSideEncryptionContext = v.Value.(string)
		case pairServerSideEncryptionCustomerAlgorithm:
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case pairServerSideEncryptionCustomerKey:
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		case pairStorageClass:
			result.HasStorageClass = true
			result.StorageClass = v.Value.(string)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.Write {
				return pairStorageWrite{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// pairStorageWriteMultipart is the parsed struct
type pairStorageWriteMultipart struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	// Generated pairs
}

// parsePairStorageWriteMultipart will parse Pair slice into *pairStorageWriteMultipart
func (s *Storage) parsePairStorageWriteMultipart(opts []Pair) (pairStorageWriteMultipart, error) {
	result := pairStorageWriteMultipart{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairExceptedBucketOwner:
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case pairServerSideEncryptionCustomerAlgorithm:
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case pairServerSideEncryptionCustomerKey:
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		// Generated pairs
		default:

			if s.pairPolicy.All || s.pairPolicy.WriteMultipart {
				return pairStorageWriteMultipart{}, services.PairUnsupportedError{Pair: v}
			}

		}
	}

	return result, nil
}

// CompleteMultipart will complete a multipart upload and construct an Object.
//
// This function will create a context by default.
func (s *Storage) CompleteMultipart(o *Object, parts []*Part, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.CompleteMultipartWithContext(ctx, o, parts, pairs...)
}

// CompleteMultipartWithContext will complete a multipart upload and construct an Object.
func (s *Storage) CompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, pairs ...Pair) (err error) {
	pairs = append(pairs, s.defaultPairs.CompleteMultipart...)
	var opt pairStorageCompleteMultipart

	defer func() {
		err = s.formatError("complete_multipart", err)
	}()

	opt, err = s.parsePairStorageCompleteMultipart(pairs)
	if err != nil {
		return
	}

	return s.completeMultipart(ctx, o, parts, opt)
}

// Create will create a new object without any api call.
//
// This function will create a context by default.
func (s *Storage) Create(path string, pairs ...Pair) (o *Object) {
	pairs = append(pairs, s.defaultPairs.Create...)
	var opt pairStorageCreate

	// Ignore error while handling local funtions.
	opt, _ = s.parsePairStorageCreate(pairs)

	return s.create(path, opt)
}

// CreateMultipart will create a new multipart.
//
// This function will create a context by default.
func (s *Storage) CreateMultipart(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateMultipartWithContext(ctx, path, pairs...)
}

// CreateMultipartWithContext will create a new multipart.
func (s *Storage) CreateMultipartWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	pairs = append(pairs, s.defaultPairs.CreateMultipart...)
	var opt pairStorageCreateMultipart

	defer func() {
		err = s.formatError("create_multipart", err, path)
	}()

	opt, err = s.parsePairStorageCreateMultipart(pairs)
	if err != nil {
		return
	}

	return s.createMultipart(ctx, path, opt)
}

// Delete will delete an Object from service.
//
// This function will create a context by default.
func (s *Storage) Delete(path string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, path, pairs...)
}

// DeleteWithContext will delete an Object from service.
func (s *Storage) DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error) {
	pairs = append(pairs, s.defaultPairs.Delete...)
	var opt pairStorageDelete

	defer func() {
		err = s.formatError("delete", err, path)
	}()

	opt, err = s.parsePairStorageDelete(pairs)
	if err != nil {
		return
	}

	return s.delete(ctx, path, opt)
}

// List will return list a specific path.
//
// This function will create a context by default.
func (s *Storage) List(path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, path, pairs...)
}

// ListWithContext will return list a specific path.
func (s *Storage) ListWithContext(ctx context.Context, path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	pairs = append(pairs, s.defaultPairs.List...)
	var opt pairStorageList

	defer func() {
		err = s.formatError("list", err, path)
	}()

	opt, err = s.parsePairStorageList(pairs)
	if err != nil {
		return
	}

	return s.list(ctx, path, opt)
}

// ListMultipart will list parts belong to this multipart.
//
// This function will create a context by default.
func (s *Storage) ListMultipart(o *Object, pairs ...Pair) (pi *PartIterator, err error) {
	ctx := context.Background()
	return s.ListMultipartWithContext(ctx, o, pairs...)
}

// ListMultipartWithContext will list parts belong to this multipart.
func (s *Storage) ListMultipartWithContext(ctx context.Context, o *Object, pairs ...Pair) (pi *PartIterator, err error) {
	pairs = append(pairs, s.defaultPairs.ListMultipart...)
	var opt pairStorageListMultipart

	defer func() {
		err = s.formatError("list_multipart", err)
	}()

	opt, err = s.parsePairStorageListMultipart(pairs)
	if err != nil {
		return
	}

	return s.listMultipart(ctx, o, opt)
}

// Metadata will return current storager metadata.
//
// This function will create a context by default.
func (s *Storage) Metadata(pairs ...Pair) (meta *StorageMeta, err error) {
	ctx := context.Background()
	return s.MetadataWithContext(ctx, pairs...)
}

// MetadataWithContext will return current storager metadata.
func (s *Storage) MetadataWithContext(ctx context.Context, pairs ...Pair) (meta *StorageMeta, err error) {
	pairs = append(pairs, s.defaultPairs.Metadata...)
	var opt pairStorageMetadata

	defer func() {
		err = s.formatError("metadata", err)
	}()

	opt, err = s.parsePairStorageMetadata(pairs)
	if err != nil {
		return
	}

	return s.metadata(ctx, opt)
}

// Read will read the file's data.
//
// This function will create a context by default.
func (s *Storage) Read(path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.ReadWithContext(ctx, path, w, pairs...)
}

// ReadWithContext will read the file's data.
func (s *Storage) ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	pairs = append(pairs, s.defaultPairs.Read...)
	var opt pairStorageRead

	defer func() {
		err = s.formatError("read", err, path)
	}()

	opt, err = s.parsePairStorageRead(pairs)
	if err != nil {
		return
	}

	return s.read(ctx, path, w, opt)
}

// Stat will stat a path to get info of an object.
//
// This function will create a context by default.
func (s *Storage) Stat(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.StatWithContext(ctx, path, pairs...)
}

// StatWithContext will stat a path to get info of an object.
func (s *Storage) StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	pairs = append(pairs, s.defaultPairs.Stat...)
	var opt pairStorageStat

	defer func() {
		err = s.formatError("stat", err, path)
	}()

	opt, err = s.parsePairStorageStat(pairs)
	if err != nil {
		return
	}

	return s.stat(ctx, path, opt)
}

// Write will write data into a file.
//
// This function will create a context by default.
func (s *Storage) Write(path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteWithContext(ctx, path, r, size, pairs...)
}

// WriteWithContext will write data into a file.
func (s *Storage) WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	pairs = append(pairs, s.defaultPairs.Write...)
	var opt pairStorageWrite

	defer func() {
		err = s.formatError("write", err, path)
	}()

	opt, err = s.parsePairStorageWrite(pairs)
	if err != nil {
		return
	}

	return s.write(ctx, path, r, size, opt)
}

// WriteMultipart will write content to a multipart.
//
// This function will create a context by default.
func (s *Storage) WriteMultipart(o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteMultipartWithContext(ctx, o, r, size, index, pairs...)
}

// WriteMultipartWithContext will write content to a multipart.
func (s *Storage) WriteMultipartWithContext(ctx context.Context, o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, err error) {
	pairs = append(pairs, s.defaultPairs.WriteMultipart...)
	var opt pairStorageWriteMultipart

	defer func() {
		err = s.formatError("write_multipart", err)
	}()

	opt, err = s.parsePairStorageWriteMultipart(pairs)
	if err != nil {
		return
	}

	return s.writeMultipart(ctx, o, r, size, index, opt)
}

func init() {
	services.RegisterServicer(Type, NewServicer)
	services.RegisterStorager(Type, NewStorager)
}
